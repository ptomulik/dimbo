---
layout: page
title: Waveform Newton
sidenav: theory
#group: navigation
---

<div id="home">
  <p>
  In what follows we approach a problem of solving an initial value problem
  with differential-algebraic equations (DAEs). In most general form DAEs are
  written as
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
          {% include theory/waveform_newton/eq0001.html %}
        </div>
      </td>
      <td width="4em">
        (1)
      </td>
    </tr>
  </table>
  where
  <math>
    <mi mathvariant="bold">y</mi>
    <mo>(</mo><mi>t</mi><mo>)</mo>
  </math> is a function to be determined,
  <math>
    <mover>
      <mi mathvariant="bold">y</mi>
      <mi mathvariant="bold">.</mi>
    </mover>
    <mo>(</mo><mi>t</mi><mo>)</mo>
  </math> its derivative.
  We'll introduce functional operator <math><mo>&#x2131;</mo></math>
  induced by <math><mi mathvariant="bold">F</mi></math>
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
          {% include theory/waveform_newton/eq0002.html %}
        </div>
      </td>
      <td width="4em">
        (2)
      </td>
    </tr>
  </table>
  </p>

  <p>
  The waveform-Newton algorithm is based on the following functional iteration
  </p>
  <p>
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
          {% include theory/waveform_newton/eq0003.html %}
        </div>
      </td>
      <td width="4em">
        (3)
      </td>
    </tr>
  </table>
  </p>

  <p>
  The symbol <math><mo>&#x2131;</mo><mo>&rsquo;</mo></math> is a Fretchet
  derivative of <math><mo>&#x2131;</mo></math>. This functional iteration may
  be written back in terms of functions 
  <math><mi mathvariant="bold">F</mi></math>,
  <math><mi mathvariant="bold">y</mi></math>,
  and <math><mi mathvariant="bold">&delta;</mi></math> (we drop iteration index
  for brevity)
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0004.html %}
        </div>
      </td>
      <td width="4em">
        (4)
      </td>
    </tr>
  </table>
  </p>

  <p>
  The above equation is a linearized DAE problem. It preserves structural
  properties such as Hessenberg form/size and thus the differential index. It
  still needs a DAE integrator to be solved.
  </p>

  <p>
  Computational procedure may be decomposed into few stages.
  <ol>
    <li>Determine
        <math>
          <msub>
            <mi mathvariant="bold">F</mi>
            <mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow>
          </msub>
        </math>,
        <math>
          <msub>
            <mi mathvariant="bold">F</mi>
            <mrow>
              <mi mathvariant="bold">y</mi>,
              <mo>(</mo><mi>k</mi><mo>)</mo>
            </mrow>
          </msub>
        </math> and
        <math>
          <msub>
            <mi mathvariant="bold">F</mi>
            <mrow>
              <mover>
                <mi mathvariant="bold">y</mi>
                <mi>.</mi>
              </mover>,
              <mo>(</mo><mi>k</mi><mo>)</mo>
            </mrow>
          </msub>
        </math>
        at discrete mesh <math><msub><mi>t</mi><mi>k</mi></msub></math>.
    </li>
    <li>
      Form interpolating polynomials (waveforms) to represent
      <math>
        <mi mathvariant="bold">F</mi>
      </math>,
      <math>
        <msub>
          <mi mathvariant="bold">F</mi>
          <mrow>
            <mi mathvariant="bold">y</mi>,
          </mrow>
        </msub>
      </math> and
      <math>
        <msub>
          <mi mathvariant="bold">F</mi>
          <mrow>
            <mover>
              <mi mathvariant="bold">y</mi>
              <mi>.</mi>
            </mover>,
          </mrow>
        </msub>
      </math>
      as a continuous functions.
    </li>
    <li>
    Solve (4) with a suitable DAE integrator, use interpolated coefficients.
    </li>
    <li>
    Repeat 1-3 until convergence.
    </li>
  </ol>
  </p>
  <p>
  Step 1. may be performed in parallel on a number of processors. If we have
  <math><mi>N</mi></math> equations in
  <math><mi mathvariant="bold">F</mi></math> and <math><mi>K</mi></math>
  timesteps <math><msub><mi>t</mi><mi>k</mi></msub></math>, then up to
  <math><mi>N</mi><op>·</op><mi>K</mi></math> processors may be used in
  parallel to evaluate <math><mi mathvariant="bold">F</mi></math>. Jacobians
  are even better, they can deploy up to
  <math><msup><mi>N</mi><mi>2</mi></msup><op>·</op><mi>K</mi></math> CPUs.
  </p>
  <p>
  In step 2, at least <math><mi>N</mi></math> CPUs may be employed.
  </p>
</div>
<!-- vim: set syntax=liquid: -->
