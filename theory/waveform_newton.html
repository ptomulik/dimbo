---
layout: page
title: Waveform Newton
sidenav: theory
#group: navigation
---

<div id="home">
  <h2>Contents</h2>
  <p>
    <ul>
      <li><a href="#general-formulation">General formulation</a></li>
      <li><a href="#general-algorithm">General algorithm</a></li>
      <li><a href="#mechanical-systems">Mechanical systems</a></li>
    </ul>
  </p>
  <h2 id="general-formulation">General formulation</h2>
  <p>
  In what follows we make an attempt to solve an initial value problem with
  differential-algebraic equations (DAEs). In most general form DAEs are
  written as
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
          {% include theory/waveform_newton/eq0001.html %}
        </div>
      </td>
      <td width="4em">
        (1)
      </td>
    </tr>
  </table>
  where
  <math>
    <mi mathvariant="bold">y</mi>
    <mo>(</mo><mi>t</mi><mo>)</mo>
  </math> is a function to be determined,
  <math>
    <mover>
      <mi mathvariant="bold">y</mi>
      <mi mathvariant="bold">.</mi>
    </mover>
    <mo>(</mo><mi>t</mi><mo>)</mo>
  </math> its derivative.
  We'll introduce functional operator <math><mo>&#x2131;</mo></math>
  induced by <math><mi mathvariant="bold">F</mi></math>
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
          {% include theory/waveform_newton/eq0002.html %}
        </div>
      </td>
      <td width="4em">
        (2)
      </td>
    </tr>
  </table>
  </p>

  <p>
  The waveform-Newton algorithm is based on the following functional iteration
  </p>
  <p>
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
          {% include theory/waveform_newton/eq0003.html %}
        </div>
      </td>
      <td width="4em">
        (3)
      </td>
    </tr>
  </table>
  The symbol <math><mo>&#x2131;</mo><mo>&rsquo;</mo></math> is the Fréchet
  derivative of <math><mo>&#x2131;</mo></math>.
  </p>

  <p>
  This functional iteration may be written back in terms of functions 
  <math><mi mathvariant="bold">F</mi></math>,
  <math><mi mathvariant="bold">y</mi></math>,
  and <math><mi mathvariant="bold">&delta;</mi></math> (we drop iteration index
  <math><mi>η-1</mi></math> for brevity)
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0004.html %}
        </div>
      </td>
      <td width="4em">
        (4)
      </td>
    </tr>
  </table>
  </p>

  <p>
  Equation (4) is a linearized DAE problem. It preserves structural properties
  such as Hessenberg form/size and thus the differential index. Finally, it
  needs a DAE integrator to be solved.
  </p>

  <h2 id="general-algorithm">General algorithm</h2>
  <p>
  The computational process may be decomposed into few stages.
  <ol>
    <li>Determine
        <math>
          <msub>
            <mi mathvariant="bold">F</mi>
            <mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow>
          </msub>
        </math>,
        <math>
          <msub>
            <mi mathvariant="bold">F</mi>
            <mrow>
              <mi mathvariant="bold">y</mi>,
              <mo>(</mo><mi>k</mi><mo>)</mo>
            </mrow>
          </msub>
        </math> and
        <math>
          <msub>
            <mi mathvariant="bold">F</mi>
            <mrow>
              <mover>
                <mi mathvariant="bold">y</mi>
                <mi>.</mi>
              </mover>,
              <mo>(</mo><mi>k</mi><mo>)</mo>
            </mrow>
          </msub>
        </math>
        at discrete mesh <math><msub><mi>t</mi><mi>k</mi></msub></math>.
    </li>
    <li>Interpolate discrete waveforms defined in 1. to generate continuous
      functions 
      <math>
        <mi mathvariant="bold">F</mi>
      </math>,
      <math>
        <msub>
          <mi mathvariant="bold">F</mi>
          <mrow>
            <mi mathvariant="bold">y</mi>,
          </mrow>
        </msub>
      </math> and
      <math>
        <msub>
          <mi mathvariant="bold">F</mi>
          <mrow>
            <mover>
              <mi mathvariant="bold">y</mi>
              <mi>.</mi>
            </mover>,
          </mrow>
        </msub>
      </math>
    </li>
    <li>Solve (4) with a suitable DAE integrator, use interpolated
    coefficients.
    </li>
    <li>Repeat 1-3 until convergence.</li>
  </ol>
  </p>
  <p>
  Step 1. may be performed in parallel on a number of processors. If we have
  <math><mi>N</mi></math> equations in
  <math><mi mathvariant="bold">F</mi></math> and <math><mi>K</mi></math>
  time-steps <math><msub><mi>t</mi><mi>k</mi></msub></math>, then up to
  <math><mi>N</mi><op>·</op><mi>K</mi></math> processors may be used in
  parallel to evaluate <math><mi mathvariant="bold">F</mi></math>. Jacobians
  are even "better" in this regard, as they can involve up to
  <math><msup><mi>N</mi><mi>2</mi></msup><op>·</op><mi>K</mi></math> CPUs.
  In step 2, <math><mi>N</mi></math> CPUs may be involved for 
  <math><mi mathvariant="bold">F</mi></math> and
  <math><msup><mi>N</mi><mi>2</mi></msup></math> for Jacobians.
  </p>

  <h2 id="mechanical-systems">Mechanical Systems</h2>

  <p>
  Mechanical systems are described mostly by Index-3 DAEs (Newton-Euler,
  Lagrange, etc.). For our purposes, we'll write the following problem
  representing a set of subsystems coupled by constraints:
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0005.html %}
        </div>
      </td>
      <td width="4em">
        (5)
      </td>
    </tr>
  </table>
  </p>

  <p>
  We assume, that the equations
  <math><mi mathvariant="bold">Φ</mi>=<mi mathvariant="bold">0</mi></math>
  and multipliers <math><mi mathvariant="bold">λ</mi></math> represent only
  constraints between subsystems. Internal constraints are handled internally
  by subsystem solvers. As a corner case one may consider single bodies to play
  role of subsystems, in which case there is no internal constraints to handle
  (as long, as we use independent coordinates to describe single body, e.g. in
  2-D). The equations (5) may then appear to be the classical Newton-Euler
  ones, for example.
  </p>
  <p>
  Subsystem solvers are just procedures represented here by functions
  <math>
    <mi mathvariant="bold">f</mi>
    <mo>(</mo>
      <mi>t</mi><mo>,</mo>
      <mi mathvariant="bold">v</mi><mo>,</mo>
      <mi mathvariant="bold">q</mi><mo>;</mo>
      <mi mathvariant="bold">e</mi>
    <mo>)</mo>
  </math>
  and
  <math>
    <mi mathvariant="bold">g</mi>
    <mo>(</mo>
      <mi>t</mi><mo>,</mo>
      <mi mathvariant="bold">v</mi><mo>,</mo>
      <mi mathvariant="bold">q</mi><mo></mo>
    <mo>)</mo>
  </math>
  which evaluate subsystem
  accelerations
  <math>
    <mover>
      <mi mathvariant="bold">v</mi>
      <mo>.</mo>
    </mover>
  </math>
  and velocities
  <math>
    <mover>
      <mi mathvariant="bold">q</mi>
      <mo>.</mo>
    </mover>
  </math>.
  The function <math><mi mathvariant="bold">f</mi></math> accepts a handle to
  function
  <math>
    <mi mathvariant="bold">e</mi>
    <mo>(</mo>
      <mi>t</mi><mo>,</mo>
      <mi mathvariant="bold">v</mi><mo>,</mo>
      <mi mathvariant="bold">q</mi>
    <mo>)</mo>
  </math>
  used to evaluate external forces acting on subsystems (including interactions
  between subsystems). To add constraints between subsystems we have to
  incorporate into
  <math>
    <mi mathvariant="bold">e</mi>
  </math>
  also the constraint reactions &mdash; we substitute
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0006.html %}
        </div>
      </td>
      <td width="4em">
        (6)
      </td>
    </tr>
  </table>
  </p>

  <p>
  If constraints between subsystems are frictionless, then
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0007.html %}
        </div>
      </td>
      <td width="4em">
        (7)
      </td>
    </tr>
  </table>
  where 
  <math>
    <mover>
      <mi mathvariant="bold">h</mi>
      <mo>¯</mo>
    </mover>
  </math>
  represents forces other than constraint reactions applied externally to
  subsystems.
  </p>

  <p>
  In this setup, the linear DAEs in the waveform-Newton iteration (4) have the
  following particular form
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0008.html %}
        </div>
      </td>
      <td width="4em">
        (8)
      </td>
    </tr>
  </table>
  with
  <math>
    <msup>
      <mi mathvariant="bold">δv</mi>
      <mi>η</mi>
    </msup>
  </math>,
  <math>
    <msup>
      <mi mathvariant="bold">δq</mi>
      <mi>η</mi>
    </msup>
  </math>,
  <math>
    <msup>
      <mi mathvariant="bold">δλ</mi>
      <mi>η</mi>
    </msup>
  </math>
  being the unknown functions.
  </p>
  <p>
  If we set
  <math>
    <mi mathvariant="bold">y</mi>
    <mo>=</mo>
    <msup>
      <mrow>
      <mo>[</mo>
        <mi mathvariant="bold">v</mi><mo>,</mo>
        <mi mathvariant="bold">q</mi><mo>,</mo>
        <mi mathvariant="bold">λ</mi>
      <mo>]</mo>
      </mrow>
      <mi>T</mi>
    </msup>
  </math>
  and
  <math>
    <mi mathvariant="bold">δ</mi>
    <mo>=</mo>
    <msup>
      <mrow>
      <mo>[</mo>
        <mi mathvariant="bold">δv</mi><mo>,</mo>
        <mi mathvariant="bold">δq</mi><mo>,</mo>
        <mi mathvariant="bold">δλ</mi>
      <mo>]</mo>
      </mrow>
      <mi>T</mi>
    </msup>
  </math>
  then standard update 
  <math>
    <msup>
      <mi mathvariant="bold">y</mi>
      <mi>η</mi>
    </msup>
    <mop>=</mop>
    <mi mathvariant="bold">y</mi>
    <mop>+</mop>
    <msup>
      <mi mathvariant="bold">δ</mi>
      <mi>η</mi>
    </msup>
  </math> 
  completes the algorithm.
  </p>

  <h3>Technical note for GPU/OpenCL</h3>
  <p>
  As the core OpenCL 1.x does not support function pointers (callbacks), it's
  not possible to define an OpenCL-based subsystem which would accept a handle
  to custom function 
  <math>
    <mi mathvariant="bold">e</mi>
    <mo>(</mo>
      <mi>t</mi><mo>,</mo>
      <mi mathvariant="bold">v</mi><mo>,</mo>
      <mi mathvariant="bold">q</mi>
    <mo>)</mo>
  </math>.
  For OpenCL implementations we thus assume
  <math>
    <mi mathvariant="bold">e</mi>
  </math>
  to be called by a wrapper, and then its value being passed to
  <math>
    <mi mathvariant="bold">f</mi>
  </math>.
  This approach is just a rearrangement of function calls and shall not alter
  the results &mdash; as long as the original function
  <math>
    <mi mathvariant="bold">f</mi>
  </math>
  calls the custom function 
  <math>
    <mi mathvariant="bold">e</mi>
  </math>
  only once an with the exactly same arguments
  <math>
    <mi>t</mi><mo>,</mo>
    <mi mathvariant="bold">v</mi><mo>,</mo>
    <mi mathvariant="bold">q</mi><mo>,</mo>
  </math>
  as their own. This is common situation, but if it's not possible, then the
  function
  <math>
    <mi mathvariant="bold">f</mi>
  </math>
  can't be longer used as a black box.
  </p>

  <h3>Evaluating coefficients</h3>
  
  <p>
  Here we try to explain a method used to evaluate coefficients appearing in
  the first two equations of (8). We assume that the function
  <math>
    <mi mathvariant="bold">f</mi>
  </math>
  is a kind of black-box. All the derivatives appearing in the first two
  equations of (8) will be determined by a finite-difference method.
  </p>

  <p>
  One feature of the waveform-Newton method is that all the functions and
  coefficients in (4) may be treated as functions of single variable
  <math>
    <mi>t</mi>
  </math>,
  so we have, for example,
  <math>
    <mo>(</mo>
      <msub>
        <mi mathvariant="bold">f</mi>
        <mi mathvariant="bold">e</mi>
      </msub>
      <msub>
        <mi mathvariant="bold">h</mi>
        <mi mathvariant="bold">λ</mi>
      </msub>
    <mo>)</mo>
    <mo>(</mo>
      <mi>t</mi>
    <mo>)</mo>
  </math>,
  <math>
    <msub>
      <mi mathvariant="bold">f</mi>
      <mi mathvariant="bold">v</mi>
    </msub>
    <mo>(</mo>
      <mi>t</mi>
    <mo>)</mo>
  </math>,
  <math>
    <mo>(</mo>
      <msub>
        <mi mathvariant="bold">f</mi>
        <mi mathvariant="bold">e</mi>
      </msub>
      <msub>
        <mi mathvariant="bold">h</mi>
        <mi mathvariant="bold">v</mi>
      </msub>
    <mo>)</mo>
    <mo>(</mo>
      <mi>t</mi>
    <mo>)</mo>
  </math>,
  <math>
    <msub>
      <mi mathvariant="bold">f</mi>
      <mi mathvariant="bold">q</mi>
    </msub>
    <mo>(</mo>
      <mi>t</mi>
    <mo>)</mo>
  </math>,
  <math>
    <mo>(</mo>
      <msub>
        <mi mathvariant="bold">f</mi>
        <mi mathvariant="bold">e</mi>
      </msub>
      <msub>
        <mi mathvariant="bold">h</mi>
        <mi mathvariant="bold">q</mi>
      </msub>
    <mo>)</mo>
    <mo>(</mo>
      <mi>t</mi>
    <mo>)</mo>
  </math>,
  etc.. At a single point <math><mi>t</mi></math> these matrices may be
  evaluated column-by-column with a finite-difference method. Taking forward
  differences as an example, the expressions for <math><mi>j</mi></math>'th
  column are given as
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0009.html %}
        </div>
      </td>
      <td width="4em">
        (9)
      </td>
    </tr>
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0010.html %}
        </div>
      </td>
      <td width="4em">
        (10)
      </td>
    </tr>
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0011.html %}
        </div>
      </td>
      <td width="4em">
        (11)
      </td>
    </tr>
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0012.html %}
        </div>
      </td>
      <td width="4em">
        (12)
      </td>
    </tr>
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0013.html %}
        </div>
      </td>
      <td width="4em">
        (13)
      </td>
    </tr>
  </table>
  where 
  <math>
    <msub>
      <mi mathvariant="bold">u</mi>
      <mi>j</mi>
    </msub>
  </math>
  is the <math><mi>j</mi></math>'th unit vector.
  </p>

  <p>
  Derivatives w.r.t.
  <math>
    <mi mathvariant="bold">v</mi>
  </math>
  and 
  <math>
    <mi mathvariant="bold">q</mi>
  </math>
  are evaluated by just perturbing either
  <math>
    <mi mathvariant="bold">v</mi>
  </math>
  or
  <math>
    <mi mathvariant="bold">q</mi>
  </math>
  and evaluating
  <math>
    <mi mathvariant="bold">f</mi>
  </math>
  or
  <math>
    <mi mathvariant="bold">g</mi>
  </math>.
  For 
  <math>
    <mi mathvariant="bold">G</mi>
  </math>
  we need to define perturbed function of the external forces
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0014.html %}
        </div>
      </td>
      <td width="4em">
        (14)
      </td>
    </tr>
  </table>
  and then
  <table width="100%">
    <tr>
      <td>
        <div class="equation">
        {% include theory/waveform_newton/eq0015.html %}
        </div>
      </td>
      <td width="4em">
        (15)
      </td>
    </tr>
  </table>
  </p>

  <h3>Technical note on the function of external forces</h3>
  <p>
    We assume that traditional solvers require a function
    <math>
      <mi mathvariant="bold">e</mi>
      <mrow>
        <mo>(</mo>
          <mrow>
            <mi>t</mi>
            <mo>,</mo>
            <mi mathvariant="bold">v</mi>
            <mo>,</mo>
            <mi mathvariant="bold">q</mi>
          </mrow>
        <mo>)</mo>
      </mrow>
    </math>
    which returns external forces acting on system. This is an entry point,
    where we can smuggle also reactions forces induced by constraints between
    subsystems. To achieve this, we may simply wrap
    <math>
      <mi mathvariant="bold">e</mi>
    </math>
    with another functional object, which adds the reaction forces. Using a
    fictitious mixed python-matlab pseudo-code I would express this as:
  </p>
  <p>
    <pre>
      class WrapH:
        def __init__(self,h,lambda):
          self.h = h
          self.lambda = lambda
        def __call__(self, t, v, q):
          return self.h(t,v,q, lambda(t))
    </pre>
    The <tt>WrapH</tt> object may be then passed to solver in place of the
    function of external forces &mdash; an appropriate code would look like:
    <pre>
      # evaluate accelerations due to external forces and lambda
      dv = f(t,v(t),q(t),WrapH(h,lambda))</pre>
  </p>
  <p>
    We may use the same wrapper to implement external forces with perturbed
    <math>
      <mi>λ</mi>
    </math>.
    For this, we just have to wrap <tt>lambda</tt> function with a wrapper
    which applies the perturbation:
    <pre>
      class Perturb:
        def __init__(self, fun, delta, j):
          self.fun = fun
          self.delta = delta
          self.j = j
        def __call__(self, t):
          # u(j) is assumed to be j'th unit vector
          return self.fun(t) + delta * u(self.j)</pre>
    and then
    <pre>
      G(:,j) = (  f(t,v(t),q(t),WrapH(h,Perturb(lambda,delta,j)))
                - f(t,v(t),q(t),WrapH(h,lambda))  )/delta</pre>
  </p>
  <p>
    On OpenCL, where we can't pass around handles to functions, we must
    rearrange the above pseudo-code, such that first all the reactions are
    evaluated and then passed to
    <math>
      <mi mathvariant="bold">f</mi>
    </math>.
    We simply have
    <pre>
      dv = f(t,v(t),q(t),h(t,v(t),q(t),lambda(t)))</pre>
    and
    <pre>
      G(:,j) = (  f(t,v(t),q(t), h(t,v(t),q(t),lambda(t) + delta*u(j)))
                - f(t,v(t),q(t), h(t,v(t),q(t),lambda(t)))  )/delta</pre>
  </p>
</div>
<!-- vim: set syntax=liquid: -->
